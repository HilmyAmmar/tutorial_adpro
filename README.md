# Module 1
## Reflection 1
Pada modul ini, ada sangat banyak materi yang saya pelajari dan saya terapkan pada program yang saya buat. Pertama, saya telah berusaha untuk menerapkan clean code pada keseluruhan kode, khususnya berkaitan dengan penamaan variable. Dalam proses penulisan kode aplikasi, saya selalu membuat nama yang sesuai dengan tujuan variable tersebut. Contohnya adalah updatedProduct yang artinya product yang akan diupdate, deletedProduct yang artinya product yang akan didelete, dsb. Tidak hanya pada variabel, saya juga menerapkan ini pada fungsi, class, unit tes, dan metode. Dimulai dari findById, deleteProduct, updateProductPost, testDeleteIfOneProduct dan seterusnya. Penamaan variabel yang sesuai, bermakna, dan informatif ini membuat saya tidak perlu membuat komen panjang dan detail. Selanjutnya, saya juga mempelajari tentang penggunaan git lebih baik lagi. Saya menerapkan branching pada setiap proses pembuatan fitur yang berbeda, sehingga akan sangat membantu dalam hal pengorganisasian kode. Selain itu, menurut saya penerapan ini mengurangi kemungkinan terjadinya merge conflict karena setiap fitur memiliki branch yang berbeda. Terakhir, saya juga mulai memahami dan menerapkan testing pada program saya, baik itu unit test dan functional test. Penerapan testing mempercepat saya dalam mengidentifikasi kesalahan atau bug dalam program saya sebelum melakukan deploy. Kesalahan pada kode saya adalah tidak adanya komen untuk menjelaskan suatu kode. Saya selalu berpikir bahwa kode ini akan mudah untuk dipahami, namun saya melupakan bahwa pemahaman setiap orang itu berbeda-beda. Kedepannya, saya akan langsung membuat komen jika memang dibutuhkan dan tetap mengacu pada aturan clean code. 

## Reflection 2
1. Menurut saya, setiap program pasti memiliki jumlah tes yang berbeda-beda. Dari sini timbul pertanyaan, bagaimana cara kita mengetahui bahwa test yang telah dibuat sudah dapat memastikan bahwa program kita telah aman tanpa bug? salah satunya adalah dengan code coverege sesuai penjelasan dari soal. Code coverege merupakan metrik yang digunakan dalam pengujian perangkat lunak untuk mengukur sejauh mana kode program telah diuji. Mungkin saat ini kita belum memakai code coverage, tapi nanti dalam pembuatan projek yang lebih besar lagi apalagi sudah skala industri, kita perlu memastikan bahwa kode yang dibuat telah diuji dengan baik sehingga akan mengurangi terjadi error ataupun munculnya bug ketika sudah deploy. Hal ini mencegah terjadinya penurunan kepuasan pengguna akibat dari program kita yang error dan terdapat bug. Menurut saya, kode program harus diuji secara terus menerus dan tidak ada yang namanya 100% code coverage, pasti akan selalu ada celah bug/keamanan yang muncul. Dikatakan demikian karena teknologi saat ini akan terus berkembang dan dengan berkembangnya teknologi, pasti akan semakin banyak tools dalam mencari celah di dalam program.

# Module 3
## Explain what principles you apply to your project
1. Single Responsibility Principle (SRP): SRP merupakan prinsip dalam proses pengembangan software dimana setiap java class hanya menjalankan satu fungsi saja. SRP sudah diimplementasikan dalam kode saya sejak modul 1. Setiap class hanya menjalankan satu fungsi yang meliputi controller, model, repository,dan service.
2. Open-Closed Principle (OCP): OCP merupakan prinsip selanjutnya dalam proses pengembangan software dimana setiap kode, baik itu metode, fungsi ataupun kelas harus bisa (open) untuk dikembangkan, tetapi tidak bisa dimodifikasi (closed). OCP telah saya implementasikan pada bagian repository. Saya menambahkan interface untuk memenuhi prinsip ini pada setiap methodnya. Ini memungkinkan kita untuk menambah fungsionalitas baru tanpa memodifikasi kode yang telah ada sebelumnya
3. Interface Segregation Principle (ISP): ISP merupakan prinsip selanjutnya dalam proses pemgembangan software dengan membagi interface yang kompleks menjadi beberapa interface yang lebih kecil sesuai dengan tujuan / fungsionalitasnya. ISP telah saya implementasikan pada bagian service dengan membagi beberapa interface dalam file yang sama menjadi interface yang lebih kecil dan spesifik pada setiap file yang berbeda.
4. Dependency Inversion Principle (DIP): DIP merupakan prinsip selanjutnya dalam proses pengembangan software dengan mengurangi ketergantungan antar kelas tingkat tinggi dan kelas tingkat rendah dengan cara mendorong penggunaan abstraksi. DIP telah saya implementasikan pada bagian service. CarServiceImpl tidak bergantung pada implementasi konkret dari 'CarRepository', melainkan hanya pada abstraksi yang dinyatakan oleh 'CarRepository'.

## Explain the advantages of applying SOLID principles to your project with examples.
1. Meningkatkan kualitas kode
Pada pengimplementasian SRP, setiap class hanya memliki satu tanggung jawab. Ini akan membuat source code menjadi lebih terstruktur dan mudah untuk dipahami oleh developer lain. Sebagai contoh, kelas CarRepository bertanggung jawab dalam menangani operasi CRUD yang berkaitan dengan Car.
2. Memudahkan maintenance software
Pada pengimplementasian OCP, setiap class/method/function harus bisa dikembangkan tanpa memodifikasi kode awal. Ini akan mengurangi terjadinya munculnya bug baru karena mengubah kode yang telah ada sebelumnya. Sebagai contoh, ketika sedang mengembangkan fitur baru, developer hanya perlu fokus pada fitur yang akan dibuatnya mengingat kode yang telah ada tidak akan dimodifikasi lagi.

## Explain the disadvantages of not applying SOLID principles to your project with examples
1. Meningkatkan kemungkinan munculnya bug baru
Ketika tidak mengimplementasikan SOLID, seluruh kode akan tergabung menjadi satu tanpa dipisah berdasarkan fungsionalitas masing-masing class/function. Perubahan yang dilakukan oleh developer pada satu bagian kode dapat berdampak pada bagian kode lainnya. Ini menyebabkan munculnya bug yang mungkin lebih susah untuk diperbaiki
2. Menyulitkan maintenance software
Tanpa pengimplementasian SOLID, developer akan mengalami kesulitan dalam mengembangkan ataupun menambahkan suatu fitur mengingat perubahan yang terjadi pada satu fitur bisa berpengaruh ke fitur lainnya yang menyebabkan munculnya bug-bug yang tidak diharapkan. Hal ini akan memperlama dan mempersulit proses maintenance. Bahkan, mungkin ada biaya tambahan yang diperlukan untuk memperbaiki softwarenya kembali seperti semula.

